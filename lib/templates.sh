#!/bin/bash

#############################################
# Template Functions (deploy.sh)
#############################################

# Number of releases to keep
RELEASES_TO_KEEP=5

# Create deployment script
create_deploy_script() {
    local username=$1
    local repository=$2
    local branch=$3
    local home_dir="/home/$username"
    local deploy_script="$home_dir/deploy.sh"
    
    # Convert repository URL to SSH format for the script
    local clone_url=$(git_url_to_ssh "$repository")
    
    cat > "$deploy_script" <<'DEPLOYEOF'
#!/bin/bash

#############################################
# Zero-Downtime Deployment Script
# Auto-generated by Cipi (Envoyer-style)
#############################################

set -e

HOME_DIR="$HOME"
RELEASES_DIR="$HOME/releases"
CURRENT_LINK="$HOME/current"
SHARED_STORAGE="$HOME/storage"
SHARED_ENV="$HOME/.env"
LOG_FILE="$HOME/logs/deploy.log"
RELEASES_TO_KEEP=5

# Placeholders replaced during script generation
REPOSITORY="REPOSITORY_PLACEHOLDER"
BRANCH="BRANCH_PLACEHOLDER"

# Generate release name (timestamp)
RELEASE_NAME=$(date +%Y%m%d%H%M%S)
RELEASE_DIR="$RELEASES_DIR/$RELEASE_NAME"

# Track if any step fails
DEPLOY_FAILED=0

# Helper to run commands and show status
run_step() {
    local description="$1"
    shift
    echo "→ $description"
    if ! "$@" 2>&1; then
        echo "  ✗ Failed: $description"
        echo "  Command: $*"
        DEPLOY_FAILED=1
        return 1
    fi
    return 0
}

# Cleanup function for failed deployments
cleanup_failed_release() {
    if [ -d "$RELEASE_DIR" ]; then
        echo "→ Cleaning up failed release..."
        rm -rf "$RELEASE_DIR"
    fi
}

# Trap to cleanup on failure
trap 'if [ $DEPLOY_FAILED -eq 1 ]; then cleanup_failed_release; fi' EXIT

echo "═══════════════════════════════════════"
echo "Zero-Downtime Deployment"
echo "Started at $(date)"
echo "Release: $RELEASE_NAME"
echo "═══════════════════════════════════════"

# Set umask for secure permissions (750 dirs, 640 files)
umask 027

# Step 1: Create new release directory
echo ""
echo "─── Step 1: Create Release Directory ───"
mkdir -p "$RELEASE_DIR"
echo "→ Created: $RELEASE_DIR"

# Step 2: Clone repository into new release
echo ""
echo "─── Step 2: Clone Repository ───"
run_step "Cloning $BRANCH branch..." git clone -b "$BRANCH" --depth 1 "$REPOSITORY" "$RELEASE_DIR" || {
    echo "✗ Failed to clone repository"
    DEPLOY_FAILED=1
    exit 1
}

cd "$RELEASE_DIR" || exit 1

# Step 3: Link shared resources
echo ""
echo "─── Step 3: Link Shared Resources ───"

# Remove the storage directory from the release (we'll symlink the shared one)
if [ -d "$RELEASE_DIR/storage" ]; then
    rm -rf "$RELEASE_DIR/storage"
fi

# Symlink shared storage
run_step "Linking shared storage..." ln -s "$SHARED_STORAGE" "$RELEASE_DIR/storage" || true

# Symlink shared .env
if [ -f "$RELEASE_DIR/.env" ]; then
    rm -f "$RELEASE_DIR/.env"
fi
run_step "Linking shared .env..." ln -s "$SHARED_ENV" "$RELEASE_DIR/.env" || true

# Step 4: Build application
echo ""
echo "─── Step 4: Build Application ───"

# Check if Laravel project
if [ -f "artisan" ]; then
    echo "→ Laravel project detected"
    
    # Composer install (must be first - artisan commands need vendor/autoload.php)
    run_step "Installing Composer dependencies..." composer install --no-interaction --prefer-dist --optimize-autoloader --no-dev || true
    
    # Check if .env exists and has APP_KEY
    if [ ! -f "$SHARED_ENV" ]; then
        echo "  ⚠ Warning: Shared .env file not found at $SHARED_ENV"
        echo "  ⚠ Please create it: cipi app env $(whoami)"
    elif ! grep -q "^APP_KEY=.\+" "$SHARED_ENV" 2>/dev/null; then
        echo "  ⚠ Warning: APP_KEY not set in .env"
        echo "  ⚠ Run: php artisan key:generate"
    fi
    
    # Run migrations
    run_step "Running database migrations..." php artisan migrate --force || true
    
    # Clear and rebuild cache
    echo "→ Optimizing application..."
    php artisan config:cache 2>&1 || true
    php artisan route:cache 2>&1 || true
    php artisan view:cache 2>&1 || true
    php artisan event:cache 2>&1 || true
    
    # Run npm if needed
    if [ -f "package.json" ]; then
        run_step "Installing NPM dependencies..." npm ci || true
        
        if grep -q '"build"' package.json; then
            run_step "Building assets..." npm run build || true
        fi
    fi
fi

# Fix permissions on bootstrap/cache (needs to be writable)
if [ -d "$RELEASE_DIR/bootstrap/cache" ]; then
    chmod -R 775 "$RELEASE_DIR/bootstrap/cache" 2>/dev/null || true
fi

# Step 5: Activate release (atomic symlink switch)
echo ""
echo "─── Step 5: Activate Release ───"

# Get the current release for reference
PREVIOUS_RELEASE=""
if [ -L "$CURRENT_LINK" ]; then
    PREVIOUS_RELEASE=$(readlink -f "$CURRENT_LINK")
fi

# Atomic symlink switch using ln -sfn
run_step "Switching to new release..." ln -sfn "$RELEASE_DIR" "$CURRENT_LINK" || {
    echo "✗ Failed to switch symlink"
    DEPLOY_FAILED=1
    exit 1
}

echo "→ Active release: $RELEASE_NAME"
if [ -n "$PREVIOUS_RELEASE" ]; then
    echo "→ Previous release: $(basename "$PREVIOUS_RELEASE")"
fi

# Step 6: Post-activation tasks
echo ""
echo "─── Step 6: Post-Activation ───"

cd "$CURRENT_LINK" || exit 1

if [ -f "artisan" ]; then
    # Restart queue workers to pick up new code
    run_step "Restarting queue workers..." php artisan queue:restart || true
    
    # Clear OPcache if available
    if php -m | grep -q OPcache; then
        echo "→ Note: You may need to reload PHP-FPM to clear OPcache"
    fi
fi

# Step 7: Cleanup old releases
echo ""
echo "─── Step 7: Cleanup Old Releases ───"

cd "$RELEASES_DIR" || exit 1

# Count releases
RELEASE_COUNT=$(ls -1d */ 2>/dev/null | wc -l)
echo "→ Total releases: $RELEASE_COUNT (keeping last $RELEASES_TO_KEEP)"

if [ "$RELEASE_COUNT" -gt "$RELEASES_TO_KEEP" ]; then
    # Get releases to delete (oldest first, excluding newest N)
    RELEASES_TO_DELETE=$(ls -1d */ | head -n -$RELEASES_TO_KEEP)
    
    for release in $RELEASES_TO_DELETE; do
        release_path="$RELEASES_DIR/$release"
        # Don't delete the current release
        if [ "$release_path" != "$RELEASE_DIR/" ] && [ "$release_path" != "$RELEASE_DIR" ]; then
            echo "→ Removing old release: $release"
            rm -rf "$RELEASES_DIR/$release"
        fi
    done
fi

# Final status
echo ""
echo "═══════════════════════════════════════"
if [ $DEPLOY_FAILED -eq 1 ]; then
    echo "Deployment completed with errors"
    echo "Finished at $(date)"
    echo "═══════════════════════════════════════"
    exit 1
else
    echo "✓ Deployment successful!"
    echo "Release: $RELEASE_NAME"
    echo "Finished at $(date)"
    echo "═══════════════════════════════════════"
fi
DEPLOYEOF
    
    # Replace placeholders
    sed -i "s|REPOSITORY_PLACEHOLDER|$clone_url|g" "$deploy_script"
    sed -i "s/BRANCH_PLACEHOLDER/$branch/g" "$deploy_script"
    
    # Set ownership and permissions
    chown "$username:$username" "$deploy_script"
    chmod 755 "$deploy_script"
}
